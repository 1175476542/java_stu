# 事务
1. 特性：原子性、一致性、隔离性、持久性
## 开启事务
1. 方式一：set autocommit = false
- 这次客户端连接，在你回复自动提交之前，解析来所有的sql执行都必须手动提交了，否则就不生效
- 这个设置只管一个连接，和其他的连接无关
2. 方式二：start transaction
- 当只有部分的sql需要构成事务，手动提交，而其他的sql还是想要自动提交的，那么我们选择方式二
- 语法
```mysql
start transaction 
... 一个事务
commit;或rollback
```
## 事务的隔离级别
- 同一个库的同一个表同一个记录，对于多个事务来说，就是共享数据
多个事务被多个线程同时执行时，那么共享数据就会出现线程安全问题
### 安全级别
- 针对不同安全级别的要求，设置了不同的隔离级别，一共四个
1. read uncommitted:可以读取未提交的
- 事务一可以读取到事务二已经修改，但是还没正式提交的数据
- 优点就是快
- 会出现脏读、不可重复读、幻读现象
2. read committed:读取已提交的数据
- 事务一，只能读取到事务二已提交的数据
- 会出现不可重复读、幻读现象
3. repeatable read:行锁
- 原来：会出现幻读
- 现在：幻读也可以避免
4. serializable:表锁
- 所有问题都可以避免
#### 几种问题
1. 脏读现象：事务一对某个记录进行修改，还未提交。事务二就看到了，那么这个事务一修改还未提交的数据就是脏数据
- 如何避免脏读：八十五隔离级别设置为2/3/4都可以
2. 不可重复读：事务一对某个表进行修改，已经提交，
但是事务二在事务一提交之前查询了这个记录，在事务一提交之后，
又查询了这个记录，对于事务二来说，出现了不可重复读的现象
在同一个事务中，前后两次对同一个记录的读取发现不一样
- 如何避免：需要设置隔离级别为3/4
3. 幻读：事务一给某个表增加了新的记录或者删除了某个表的记录（记录数有变化），并且提交了
事务二在事务一提交之前，查询了这个表，在事务一提交之后，又查询了这个表
对于事务二来说，前后两次的记录数不一样。好比出现幻觉一样，多出或少了数据
- 如何避免：需要设置隔离等级为4，但是在mysql5之后，在隔离级别3的时候就可以避免幻读了
#### 如何查看当前连接隔离级别
1. 语法：
- select @@tx_isolation
2. mysql的默认隔离级别：repeatable read
#### 如何修改当前连接的隔离级别
1. 语法
```mysql
set tx_isolation = 'read-uncommitted'
```
#### 事务对DDL无效
1. 事务属于DCL，事务的回滚只对insert，update，delete有效
2. 对create，drop，等DDL无效
## 用户与权限
